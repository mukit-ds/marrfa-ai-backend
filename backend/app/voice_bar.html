<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Hold-to-talk</title>
  <style>
    body { font-family: system-ui, Arial; margin: 16px; }
    .row { display:flex; gap:12px; align-items:center; }
    #mic {
      width:44px; height:44px; border-radius:999px;
      border:1px solid #ddd; background:#fff; cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
      font-size:18px;
    }
    #mic.rec { background:#111827; color:#fff; border-color:#111827; }
    #live { padding:10px 12px; border:1px solid #eee; border-radius:12px; min-width:320px; }
    #final { margin-top:10px; color:#111827; }
  </style>
</head>
<body>
  <div class="row">
    <div id="mic" title="Hold to talk">ðŸŽ¤</div>
    <div id="live">Hold ðŸŽ¤, speakâ€¦</div>
  </div>
  <div id="final"></div>

<script>
const WS_URL = "ws://127.0.0.1:8000/ws/stt"; // change if different
const micBtn = document.getElementById("mic");
const liveEl = document.getElementById("live");
const finalEl = document.getElementById("final");

let ws, audioCtx, source, processor, stream;
let running = false;
let pendingDelta = "";

function f32ToPcm16Base64(float32, targetRate, inRate) {
  // resample (naive) to 24k; for best quality use AudioWorklet resampler
  const ratio = inRate / targetRate;
  const outLen = Math.floor(float32.length / ratio);
  const pcm16 = new Int16Array(outLen);

  for (let i=0; i<outLen; i++) {
    const idx = Math.floor(i * ratio);
    let s = float32[idx] || 0;
    s = Math.max(-1, Math.min(1, s));
    pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
  }

  // base64 encode
  const bytes = new Uint8Array(pcm16.buffer);
  let bin = "";
  const chunk = 0x8000;
  for (let i=0; i<bytes.length; i+=chunk) {
    bin += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
  }
  return btoa(bin);
}

async function startHold() {
  if (running) return;
  running = true;
  pendingDelta = "";
  micBtn.classList.add("rec");
  liveEl.textContent = "Listeningâ€¦";
  finalEl.textContent = "";

  ws = new WebSocket(WS_URL);

  ws.onmessage = (ev) => {
    const msg = JSON.parse(ev.data);
    if (msg.type === "delta") {
      pendingDelta += msg.text;
      liveEl.textContent = pendingDelta;
    }
    if (msg.type === "final") {
      const txt = msg.text || pendingDelta;
      finalEl.textContent = "Final: " + txt;
      liveEl.textContent = "Hold ðŸŽ¤, speakâ€¦";
      pendingDelta = "";
      // TODO: here you can auto-send txt to your /api/chat
      // fetch("http://127.0.0.1:8000/api/chat", {method:"POST", headers:{'Content-Type':'application/json'}, body: JSON.stringify({query: txt, page:1, per_page:12})})
    }
    if (msg.type === "error") {
      liveEl.textContent = "Error: " + msg.message;
    }
  };

  stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  source = audioCtx.createMediaStreamSource(stream);

  // ScriptProcessor is widely supported; AudioWorklet is better if you want even lower latency
  processor = audioCtx.createScriptProcessor(4096, 1, 1);
  source.connect(processor);
  processor.connect(audioCtx.destination);

  const targetRate = 24000;

  processor.onaudioprocess = (e) => {
    if (!running || ws.readyState !== 1) return;
    const input = e.inputBuffer.getChannelData(0);
    const b64 = f32ToPcm16Base64(input, targetRate, audioCtx.sampleRate);
    ws.send(JSON.stringify({ type: "audio", pcm16_b64: b64 }));
  };
}

function stopHold() {
  if (!running) return;
  running = false;
  micBtn.classList.remove("rec");

  try { ws && ws.readyState === 1 && ws.send(JSON.stringify({type:"stop"})); } catch {}
  try { processor && processor.disconnect(); } catch {}
  try { source && source.disconnect(); } catch {}
  try { audioCtx && audioCtx.close(); } catch {}
  try { stream && stream.getTracks().forEach(t => t.stop()); } catch {}
}

micBtn.addEventListener("pointerdown", startHold);
micBtn.addEventListener("pointerup", stopHold);
micBtn.addEventListener("pointerleave", stopHold);
micBtn.addEventListener("touchend", stopHold);
</script>
</body>
</html>
